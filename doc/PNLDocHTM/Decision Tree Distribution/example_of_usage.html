<html>
<link rel="stylesheet" type="text/css" href="css/table.css">
<title>Example of usage</title>
<body>
<table>
	<tr>
		<td colspan=2 align = "center"><h1><font color = "#0000ff">Example of usage for Bayesian networks with decision Tree nodes</h1></td>
	</tr>
	<tr>
		<td colspan=2><p>Document contains necessary information to start a simple test in inference algorithm for Bayesian networks with decision Tree nodes that are realized in PNL. At first simple network is presented. Further an example for this algorithm is described.</p></td>
	</tr>
	<tr>
		<td colspan=2 bgcolor = "#0000ff"><h2><font color="#ffffff">Initial model</font></h2></td>
	</tr>
	<tr>
		<td colspan=2><p>Consider the following network.</p><img src="bnet.gif" align = "all"></img><br> <p>Consider a net that contains two discrete nodes d1, d2 and one tree node t1. Node sizes are 2, 3 and 2. 
Nodes d1 and d2 are discrete parents of discrete tree node t1. The task is to find out the probability distribution on Desgion Tree node using evidence on somr of his parents.</p>
			<p>Distribution on decision Tree node depends on distribution parameters of continous nodes, these dependences must be defined with help of quiestions on non terminia nodes of decision Tree.</p>
			
</td>
</tr>
<tr>
<td>  <img src="dt.gif" > 
		</td><td align = "left"><br>Nodes n1, n2, and n5 are non-terminal nodes, n3, n4, n6 and n7 are terminal nodes.
		<br>Node n1 question is d1 = 0.
		<br>Node n2 question is d2 >= 1.
		<br>Node n5 question is d2 = 0.
		<br>Node n3 distribution is 0.5, 0.5.
		<br>Node n4 distribution is 0.7, 0.3.
		<br>Node n6 distribution is 0.4, 0.6.
		<br>Node n7 distribution is 0.3, 0.7.
  	</td>
</tr>
<tr>
<td colspan=2>
<p>To load this model you may use the following function:</p>
			<font class = "code">
			<pre>
CBNet* CreatedecisionTreeExample(void)
{
  //Creating Bayesian network</font>
const int nnodes = 3; <font class="comment">//Number of nodes</font>
const int numNt = 2; <font class="comment">//number of Node types (all nodes are discrete)</font>
CNodeType* nodeTypes = new CNodeType [numNt];
nodeTypes[0] = CNodeType( 1,2 ); <font class="comment">// discrete node, size 2</font>
nodeTypes[1] = CNodeType( 1,3 ); <font class="comment">// discrete node, size 3</font>
int nodeAssociation[] = { 0, 1, 0 };

int numOfNeigh[] = { 1, 1, 2 };
int neigh0[] = { 2 };
int neigh1[] = { 2 };
int neigh2[] = { 0, 1 };

ENeighborType orient0[] = { ntChild };
ENeighborType orient1[] = { ntChild };
ENeighborType orient2[] = { ntParent, ntParent };

int *neigh[] = { neigh0, neigh1, neigh2 };
ENeighborType *orient[] = { orient0, orient1, orient2 };

CGraph* pGraph = CGraph::Create(nnodes, numOfNeigh, neigh, orient);

<font class="comment">//Create static BNet</font>
CBNet* pBNet = CBNet::Create(nnodes, numNt, nodeTypes, nodeAssociation, pGraph);
pBNet->AllocFactors();

int nnodes0 = 1;
int domain0[] = { 0 };
float table0[] = { 0.4f, 0.6f };
CTabularCPD *pCPD0 = CTabularCPD::Create(domain0, nnodes0, 
  pBNet->GetModelDomain(), table0);
pCPD0->AllocMatrix(table0, matTable);
pBNet->AttachFactor(pCPD0);

int nnodes1 = 1;
int domain1[] = { 1 };
float table1[] = { 0.4f, 0.1f, 0.5f };
CTabularCPD *pCPD1 = CTabularCPD::Create(domain1, nnodes1,
  pBNet->GetModelDomain(), table1);
pCPD0->AllocMatrix(table1, matTable);
pBNet->AttachFactor(pCPD1);

int nnodes2 = 3;
int domain2[] = { 0, 1, 2 };
CTreeCPD *pCPD2 = CTreeCPD::Create(domain2, nnodes2, 
  pBNet->GetModelDomain());

<font class="comment">//creating tree on node t1</font>
const int nnodesT = 7; <font class="comment">//Number of nodes in the tree</font>
int neigh0T[] = { 1, 2 };
int neigh1T[] = { 0, 3, 4 };
int neigh2T[] = { 0 };
int neigh3T[] = { 1 };
int neigh4T[] = { 1, 5, 6 };
int neigh5T[] = { 4 };
int neigh6T[] = { 4 };

ENeighborType orient0T[] = { ntChild, ntChild };
ENeighborType orient1T[] = { ntParent, ntChild, ntChild };
ENeighborType orient2T[] = { ntParent };
ENeighborType orient3T[] = { ntParent };
ENeighborType orient4T[] = { ntParent, , ntChild, ntChild };
ENeighborType orient5T[] = { ntParent };
ENeighborType orient6T[] = { ntParent };

int *neighT[] = { neigh0T, neigh1T, neigh2T, neigh3T, neigh4T, neigh5T, neigh6T };
ENeighborType *orientT[] = { orient0T, orient1T, orient2T, orient3T, orient4T, orient5T, orient6T };

CGraph* pGraphT = CGraph::Create(nnodesT, numOfNeighT, neighT, orientT);

<font class="comment">// filling tree nodes values on node t1</font>
TreeNodeFields fnode0;
TreeNodeFields fnode1;
TreeNodeFields fnode2;
TreeNodeFields fnode3;
TreeNodeFields fnode4;
TreeNodeFields fnode5;
TreeNodeFields fnode6;

fnode0.isTerminal = false; <font class="comment">// non-terminal node</font>
fnode0.Question = 0; <font class="comment">// it means that question type is =</font>
fnode0.questionValue = 0; <font class="comment">//it means that we ask value 0</font>
fnode0.node_index = 0; <font class="comment">// asked node index</font> 

fnode1.isTerminal = false; <font class="comment">// non-terminal node</font>
fnode1.Question = 1; <font class="comment">//it means that question type is >=</font>
fnode1.questionValue = 1; <font class="comment">//it means that we ask value 1</font>
fnode1.node_index = 1; <font class="comment">// asked node index</font>

fnode2.isTerminal = true; <font class="comment">// terminal node</font>
fnode2.probVect = new float[2];
fnode2.probVect[0] = 0.5f; <font class="comment">// probability to take 0 on this node</font>
fnode2.probVect[1] = 0.5f; <font class="comment">// probability to take 1 on this node</font>

fnode3.isTerminal = true;
fnode3.probVect = new float[2];
fnode3.probVect[0] = 0.7f; <font class="comment">// probability to take 0 on this node</font>
fnode3.probVect[1] = 0.3f; <font class="comment">// probability to take 1 on this node</font>

fnode4.isTerminal = false; <font class="comment">// non-terminal node</font>
fnode4.Question = 0;  <font class="comment">//it means that question type is =</font>
fnode4.questionValue = 0 <font class="comment">//it means that we ask value 0</font>
fnode4.node_index = 1; <font class="comment">// asked node index</font>

fnode5.isTerminal = true; <font class="comment">// terminal node</font>
fnode5.probVect = new float[2];
fnode5.probVect[0] = 0.4f; <font class="comment">// probability to take 0 on this node</font>
fnode5.probVect[1] = 0.6f; <font class="comment">// probability to take 1 on this node</font>

fnode6.isTerminal = true; <font class="comment">// terminal node</font>
fnode6.probVect = new float[2];
fnode6.probVect[0] = 0.3f; <font class="comment">// probability to take 0 on this node</font>
fnode6.probVect[1] = 0.7f; <font class="comment">// probability to take 1 on this node</font>

TreeNodeFields fields[7];
fields[0] = fnode0;
fields[1] = fnode1;
fields[2] = fnode2;
fields[3] = fnode3;
fields[4] = fnode4;
fields[5] = fnode5;
fields[6] = fnode6;

<font class="comment">//follow function creates tree on decision tree node</font>
pCPD2->UpdateTree(pGraphT,fields);

pBNet->AttachFactor(pCPD2);

  return pBNet;
}

			</pre></font>
		</td>
	</tr>
	<tr>
		<td bgcolor = "#0000ff"><h2><font color="#ffffff">Implementation</font></h2></td>
	</tr>
	<tr>
		<td>
		To start inference  with this network you may use the following source code.
		<font class = "code">
		<pre>
int main()
{
<font class="comment">//---- Network creation -----------------------------------------------------</font>
  CBNet *pBNet = NULL;
  pBNet = CreatedecisionTreeExample();
<font class="comment">//---- Inference engine creation ---------------------------------------------</font>
  CGibbsSamplingInfEngine *pGibbsInf;
  pGibbsInf = CGibbsSamplingInfEngine::Create( pBNet );
<font class="comment">//---- Evidence Creation ----------------------------------------------------</font>   
  const int numOfObsNds  = 2;
  const int obsNds[]     = { 0, 1 }; 
  valueVector obsNdsVals(numOfObsNds);
  obsNdsVals[0].SetInt(0);
  obsNdsVals[1].SetInt(1);
	
  CEvidence *pEvidence = CEvidence::Create( pBNet, numOfObsNds, obsNds,
       obsNdsVals );   
<font class="comment">//---- Starting Inference process -------------------------------------------</font>  
  pGibbsInf->SetMaxTime( 10000);
  pGibbsInf->SetBurnIn( 1000 );

  intVecVector queries(1);
  queries[0].clear();
  queries[0].push_back( 10 );
 
  pGibbsInf->SetQueries( queries );    
  pGibbsInf->EnterEvidence( pEvidence );
  
<font class="comment">//---- Result Output --------------------------------------------------------</font>
  const int querySz1 = 1;
  const int query1[] = { 10 };
  pGibbsInf->MarginalNodes( query1, querySz1 );
    
  const CPotential *pQueryPot;
  pQueryPot = pGibbsInf->GetQueryJPD();
     
  pQueryPot->Dump();  
<font class="comment">//---- Free the Memory ------------------------------------------------------</font> 
  delete pEvidence;
  delete pGibbsInf;
  delete pBNet;
  
  return 0;
}

		</pre>
		</font>
		</td>
	</tr>
</table>
<body>
<html>