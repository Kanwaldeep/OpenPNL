<html>
<link rel="stylesheet" type="text/css" href="css/table.css">
<title>Parallel Loopy Belief Inference Engine: Example of usage</title>
<body>
<table>
	<tr>
		<td align = "center"><h1><font color = "#0000ff">Example of usage for parallel Loopy Belief inference engine</h1></td>
	</tr>
	<tr>
		<td><p>Document contains necessary information to start a simple test in parallel loopy belief inference algorithm that is realized in PNL. At first standard test “Asia” is defined. Further an example for this algorithm is described.</p></td>
	</tr>
	<tr>
		<td bgcolor = "#0000ff"><h2><font color="#ffffff">Initial model</font></h2></td>
	</tr>
	<tr>
		<td><p>Consider the following network.</p><img src="Images/AsiaExample.png" align = "all"></img><br> <p>Shortness-of-breath (dyspnoea) [D] may be due to tuberculosis [T], lung cancer [L] or bronchitis [B], or none of them, or more than one of them. A recent visit to Asia [A] increases the risk of tuberculosis, while smoking [S] is known to be a risk factor for both lung cancer and bronchitis. The result of a single chest X-ray [X] does not discriminate between lung cancer and tuberculosis, neither does the presence or absence of dyspnoea.</p>
			<p>To load this model you may use the following function:</p>
			<font class = "code">
			<pre>
CBNet* CreateAsiaBNet()
{
	const int numberOfNodes = 8;
	const int numberOfNodeTypes = 1;

	int i;
	
 	int numOfNeigh[] = { 2, 1, 2, 2, 2, 4, 2, 1 };
	
 	int neigh0[] = { 2, 3 };
	int neigh1[] = { 4 };
	int neigh2[] = { 0, 6 };
	int neigh3[] = { 0, 5 };
	int neigh4[] = { 1, 5};
	int neigh5[] = { 3, 4, 6, 7};
	int neigh6[] = { 2, 5 };
	int neigh7[] = { 5 };
	
	ENeighborType orient0[] = { ntChild, ntChild };
	ENeighborType orient1[] = { ntChild };
	ENeighborType orient2[] = { ntParent, ntChild };
	ENeighborType orient3[] = { ntParent, ntChild };
	ENeighborType orient4[] = { ntParent, ntChild };
	ENeighborType orient5[] = { ntParent, ntParent, ntChild, ntChild };
	ENeighborType orient6[] = { ntParent, ntParent };
	ENeighborType orient7[] = { ntParent };
	
	int *neigh[] = { neigh0,  neigh1, neigh2, neigh3, neigh4, neigh5,
		neigh6, neigh7 };
	ENeighborType *orient[] = { orient0, orient1, orient2, orient3, 
		orient4, orient5, orient6, orient7 };
	
	CGraph *pGraph = CGraph::Create(numberOfNodes, numOfNeigh, 
		neigh, orient);
	
	CNodeType *nodeTypes = new CNodeType [numberOfNodeTypes];
	nodeTypes[0].SetType(1, 2);

	int *nodeAssociation = new int[numberOfNodes];

	for( i = 0; i < numberOfNodes; i++ )
	{
		nodeAssociation[i] = 0;
	}

	CBNet *pBNet = CBNet::Create( numberOfNodes, numberOfNodeTypes, 
		nodeTypes, nodeAssociation, pGraph );

 	CModelDomain* pMD = pBNet -> GetModelDomain();
	
	<font class="comment">//number of parameters is the same as number of nodes - one CPD per node</font>
	CFactor **myParams = new CFactor*[numberOfNodes];
	int *nodeNumbers = new int [numberOfNodes];
	int domain0[] = { 0 };
	int domain1[] = { 1 };
	int domain2[] = { 0, 2 };
	int domain3[] = { 0, 3 };
	int domain4[] = { 1, 4 };
	int domain5[] = { 3, 4, 5 };
	int domain6[] = { 2, 5, 6 };
	int domain7[] = { 5, 7 };
	int *domains[] = { domain0, domain1, domain2, domain3, domain4,
		domain5, domain6, domain7 };
	nodeNumbers[0] = 1;
	nodeNumbers[1] = 1;
	nodeNumbers[2] = 2;
	nodeNumbers[3] = 2;
	nodeNumbers[4] = 2;
	nodeNumbers[5] = 3;
	nodeNumbers[6] = 3;
	nodeNumbers[7] = 2;

	pBNet->AllocParameters();

	for( i = 0; i < numberOfNodes; i++ )
	{
		myParams[i] = CTabularCPD::Create( domains[i], 
			nodeNumbers[i], pMD);
        }
	
	<font class="comment">// data creation for all CPDs of the model</font>
	float data0[] = {0.5f, 0.5f};
	float data1[] = {0.99f, 0.01f};
	float data2[] = {0.7f, 0.3f, 0.4f, 0.6f};
	float data3[] = {0.99f, 0.01f, 0.9f, 0.1f};
	float data4[] = {0.99f, 0.01f, 0.95f, 0.05f};
	float data5[] = {1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f};
	float data6[] = {0.9f, 0.1f, 0.3f, 0.7f, 0.2f, 0.8f, 0.1f, 0.9f};
	float data7[] = {0.95f, 0.05f, 0.02f, 0.98f};
	float *data[] = { data0, data1, data2, data3, data4, data5, 
		data6, data7};

	for( i = 0; i < numberOfNodes; i++ )
	{
		myParams[i] -> AllocMatrix(data[i], matTable);
		pBNet -> AttachParameter(myParams[i]);
	}

    return pBNet;
}

			</pre></font>
		</td>
	</tr>
	<tr>
		<td bgcolor = "#0000ff"><h2><font color="#ffffff">Implementation</font></h2></td>
	</tr>
	<tr>
		<td>
		To start inference with Pararllel Loopy Belief Inference Engine you may use the following source code.
		<font class = "code">
		<pre>
int main()
{
	<font class="comment">// - Bayesian Network "Asia" creation --------------------------------------</font>
  	CBNet* pBNet;
  	pBNet = CreateAsiaBNet();

	<font class="comment">// - Evidence definition ---------------------------------------------------</font>
	const int numOfObsNds = 2;
	const int obsNds[] = { 0, 3 };
    	valueVector obsNdsVals(2);
    	obsNdsVals[0].SetInt(1);
    	obsNdsVals[1].SetInt(0);
    	CEvidence *pEvidence = NULL;
    	pEvidence = CEvidence::Create(pBNet, numOfObsNds, obsNds, obsNdsVals);

	<font class="comment">// - Inference engine creation --------------------------------------------</font>
	CParPearlInfEngine *pParInfEng;
    	pParInfEng = CParPearlInfEngine::Create(pBNet);

	<font class="comment">// - Run Open MP inference engine -----------------------------------------</font>
	pParInfEng -> EnterEvidenceOMP(pEvidence);
	
	<font class="comment">/* - If you want to run MPI version of Paralell Loopy Belief Inference 
		Engine, you may use the folowing function call: 
	pParPearl -> EnterEvidence(pEvidence); */</font>
	

	<font class="comment">// - Get the marginals for a set of nodes for Parallel Pearl --------------</font>
    	int i, numOfNdsTmp;
    	for (i = 0, numOfNdsTmp = pBNet->GetNumberOfNodes();
        	i < numOfNdsTmp; ++i)
    	{
        	pParInfEng->MarginalNodes(&i, 1);
        	pParInfEng->GetQueryJPD()->Dump();
    	}

	<font class="comment">// - Free the memory ------------------------------------------------------</font>
	delete pEvidence;
	delete pParInfEng;
	delete pBNet;

	return 0;
}


		</pre>
		</font>
		</td>
	</tr>
</table>
<body>
<html>