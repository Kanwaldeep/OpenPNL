<html>
<link rel="stylesheet" type="text/css" href="css/table.css">
<title>Example of usage</title>
<body>
<table>
	<tr>
		<td align = "center"><h1><font color = "#0000ff">Example of usage for Bayesian networks with SoftMax nodes</h1></td>
	</tr>
	<tr>
		<td><p>Document contains necessary information to start a simple test in learning algorithm for Bayesian networks with SoftMax nodes that are realized in PNL. At first simple network is presented. Further an example for this algorithm is described.</p></td>
	</tr>
	<tr>
		<td bgcolor = "#0000ff"><h2><font color="#ffffff">Initial model</font></h2></td>
	</tr>
	<tr>
		<td><p>Consider the following network.</p><img src="model.gif" align = "all"></img><br> <p>Nodes, which are marked by letter C are continuous, and nodes, which are marked by letter D are discrete. A SoftMax node (marked by letters SM) is a discrete node, which has both continuous and discrete parents. All discrete nodes have two possible states. The task is to find out the probability distribution on SoftMax node using evidences.</p>
			<p>Distribution on SoftMax node depends on distribution parameters of continous nodes, these dependences must be defined for every state configuration of discrete parents.</p>
			<p>To load this model you may use the following function:</p>
			<font class = "code">
			<pre>
CBNet* CreateSoftMaxExample(void)
{
  const int numOfNds = 5;
  int numOfNbrs[numOfNds] = { 1, 1, 1, 1, 4 };

  int nbrs0[] = { 4 };
  int nbrs1[] = { 4 };
  int nbrs2[] = { 4 };
  int nbrs3[] = { 4 };
  int nbrs4[] = { 0, 1, 2, 3};
    
  ENeighborType nbrsTypes0[] = { ntChild };
  ENeighborType nbrsTypes1[] = { ntChild };
  ENeighborType nbrsTypes2[] = { ntChild };
  ENeighborType nbrsTypes3[] = { ntChild };
  ENeighborType nbrsTypes4[] = { ntParent, ntParent, ntParent, ntParent };

  int *nbrs[] = { nbrs0, nbrs1, nbrs2, nbrs3, nbrs4 };
  ENeighborType *nbrsTypes[] = { nbrsTypes0, nbrsTypes1, nbrsTypes2, nbrsTypes3, nbrsTypes4};

  CGraph* pGraph = CGraph::Create( numOfNds, numOfNbrs, nbrs, nbrsTypes );
    
  <font class="comment">//  Creation of the Model Domain.</font>
 
  CModelDomain* pMD;

  nodeTypeVector variableTypes;
    
  int nVariableTypes = 2;
  variableTypes.resize( nVariableTypes );
   
  variableTypes[0].SetType( 0, 1 ); <font class="comment">// continuous node</font>
  variableTypes[1].SetType( 1, 2 ); <font class="comment">// discrete node</font>
  
  intVector variableAssociation;  
  int nnodes = pGraph->GetNumberOfNodes();
  variableAssociation.assign(nnodes, 1);
  variableAssociation[0] = 0;
  variableAssociation[1] = 0;
  variableAssociation[2] = 1;
  variableAssociation[3] = 1;
  variableAssociation[4] = 1;

  pMD = CModelDomain::Create( variableTypes, variableAssociation );
    
<font class="comment">  //  Creation base for BNet using Graph, and Model Domain</font>
    
  CBNet *pBNet = CBNet::Create(pGraph, pMD);
    
<font class="comment">  //  Allocation space for all factors of the model</font>
  pBNet->AllocFactors();

<font class="comment">  //  continous node 0</font>
  int nnodes0 = 1;
  int domain0[] = { 0 };
  float mean0 = 0.0f;
  float cov0 = 1.0f;
  CGaussianCPD *pCPD0 = CGaussianCPD::Create( domain0, nnodes0, pMD );
  pCPD0->AllocDistribution( &mean0, &cov0, 1.0f, NULL );
  pBNet->AttachFactor( pCPD0 );
  
<font class="comment">  //  continuous node 1</font>
  int nnodes1 = 1;
  int domain1[] = { 1 };
  float mean1 = 0.0f;
  float cov1 = 1.0f;
  CGaussianCPD *pCPD1 = CGaussianCPD::Create( domain1, nnodes1, pMD );
  pCPD1->AllocDistribution( &mean1, &cov1, 1.0f, NULL );
  pBNet->AttachFactor( pCPD1 );

<font class="comment">  //  discrete node 2</font>
  int nnodes2 = 1;
  int domain2[] = { 2 };
  float table2[] = { 0.7f, 0.3f};

  CTabularCPD *pCPD2 = CTabularCPD::Create( domain2, nnodes2, pMD, table2 );
  pCPD2->AllocMatrix(table2, matTable);
  pBNet->AttachParameter(pCPD2);

<font class="comment">  //  discrete node 3</font>
  int nnodes3 = 1;
  int domain3[] = { 3 };
  float table3[] = { 0.4f, 0.6f};

  CTabularCPD *pCPD3 = CTabularCPD::Create( domain3, nnodes3, pMD, table3 );
  pCPD2->AllocMatrix(table3, matTable);
  pBNet->AttachParameter(pCPD3);


  <font class="comment">// softmax  node 4</font>
  int nnodes4 = 5;
  int domain4[] = { 0, 1, 2, 3, 4 };
  CSoftMaxCPD *pCPD4 = CSoftMaxCPD::Create( domain4, nnodes4, pMD );

  <font class="comment">//Defining the start SoftMax distribution parameters<br>  //for every state configuration of discrete parents </font>  
  int parInd00[] = { 0, 0 };

  float weight00[] = { 0.1f, 0.3f, 0.3f, 0.3f };
  float offset00[] = { 0.4f, 0.6f };
  
  pCPD4->AllocDistribution( weight00, offset00, parInd00 );
  
  int parInd01[] = { 0, 1 };

  float weight01[] = { 0.3f, 0.2f, 0.2f, 0.3f };
  float offset01[] = { 0.1f, 0.9f };

  pCPD4->AllocDistribution( weight01, offset01, parInd01 );

  int parInd10[] = { 1, 0 };

  float weight10[] = { 0.7f, 0.3f, 0.0f, 0.0f };
  float offset10[] = { 0.4f, 0.6f };

  pCPD4->AllocDistribution( weight10, offset10, parInd10 );
  
  int parInd11[] = { 1, 1 };

  float weight11[] = { 0.2f, 0.3f, 0.2f, 0.3f };
  float offset11[] = { 0.4f, 0.6f };

  pCPD4->AllocDistribution( weight11, offset11, parInd11 );

  pBNet->AttachFactor( pCPD4 );

  return pBNet;
}

			</pre></font>
		</td>
	</tr>
	<tr>
		<td bgcolor = "#0000ff"><h2><font color="#ffffff">Implementation</font></h2></td>
	</tr>
	<tr>
		<td>
		To start learning  with this network you may use the following source code.
		<font class = "code">
		<pre>
int main()
{
<font class="comment">//---- Network creation -----------------------------------------------------</font>
  CBNet *pBNet = NULL;
  pBNet = CreateSoftMaxExample();

<font class="comment">//---- Learning engine creation ---------------------------------------------</font>
  CEMLearningEngine *pLearnEng = NULL;
  pLearnEng = CEMLearningEngine::Create(pBNet);

<font class="comment">//---- Evidence Creation ----------------------------------------------------</font>   
  int NumOfNodes = pBNet->GetNumberOfNodes(); 
  valueVector vls;
  CEvidence **m_pEv;
  m_pEv = new CEvidence *[NumOfNodes];

   int nObsNds = NumOfNodes;
   const CModelDomain *pMD = pBNet->GetModelDomain();
   int *obsNds = new int [nObsNds];
   for (int i=0; i<nObsNds; i++) obsNds[i] = i;
   
   for (i = 0; i<&lt;> < </&lt;>10; i++)
  {
    GenerateSoftMaxEvidence(pBNet, -1.0, 1.0, vls);
    m_pEv[i] = CEvidence::Create( pMD, nObsNds, obsNds, vls );
  }
    
<font class="comment">//---- Starting Learning process -------------------------------------------</font>  
  pLearnEng->SetData(10, m_pEv);
        
  pLearnEng->SetMaxIterEM(20);
  pLearnEng->SetMaximizeMethod(mmConjugateGradient);
  pLearnEng->Learn(); 
  
<font class="comment">//---- Result Output --------------------------------------------------------</font>
  int numOfNdsTmp = pBNet->GetNumberOfNodes();
  for (i = 0; i < numOfNdsTmp; i++)
  {
    pBNet->GetFactor(i)->GetDistribFun()->Dump();
  }
    
<font class="comment">//---- Free the Memory ------------------------------------------------------</font> 
  delete pLearnEng;
  delete pBNet;
  
  return 0;
}

		</pre>
		</font>
		</td>
	</tr>
</table>
<body>
<html>