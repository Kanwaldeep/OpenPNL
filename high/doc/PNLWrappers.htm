<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML><HEAD><TITLE>PNL Wrappers Reference</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251"><LINK 
href="style.css" type=text/css charset=ISO-8859-1 
rel=STYLESHEET>
<META content="MSHTML 6.00.2800.1400" name=GENERATOR></HEAD>
<BODY>
<H1>PNL high-level interface</H1>
<HR>

<P>
<UL>
  <LI><A 
  href="#decl_Class_BayesNet">Class BayesNet</A> 
  <UL>
    <LI><A 
    href="#decl_AddArc">AddArc</A> 

    <LI><A 
    href="#decl_AddEvidToBuf">AddEvidToBuf</A> 

    <LI><A 
    href="#decl_AddNode">AddNode</A> 

    <LI><A 
    href="#decl_BayesNet">BayesNet</A> 

    <LI><A 
    href="#decl_ClearEvid">ClearEvid</A> 

    <LI><A 
    href="#decl_ClearEvidBuf">ClearEvidBuf</A> 

    <LI><A 
    href="#decl_CurEvidToBuf">CurEvidToBuf</A> 

    <LI><A 
    href="#decl_DelArc">DelArc</A> 

    <LI><A 
    href="#decl_DelNode">DelNode</A> 

    <LI><A 
    href="#decl_EditEvidence">EditEvidence</A> 

    <LI><A 
    href="#decl_GenerateEvidences">GenerateEvidences</A> 

    <LI><A 
    href="#decl_GetChildren">GetChildren</A> 

    <LI><A 
    href="#decl_GetGaussianMean">GetGaussianMean</A> 

    <LI><A 
    href="#decl_GetGaussianCovar">GetGaussianCovar</A> 

    <LI><A 
    href="#decl_GetJPD">GetJPD</A> 

    <LI><A 
    href="#decl_GetMPE">GetMPE</A> 

    <LI><A 
    href="#decl_GetNeighbours">GetNeighbours</A> 

    <LI><A 
    href="#decl_GetNodeType">GetNodeType</A> 

    <LI><A 
    href="#decl_GetParents">GetParents</A> 

    <LI><A 
    href="#decl_GetProperty">GetProperty</A> 

    <LI><A 
    href="#decl_GetPTabular">GetPTabular</A> 

    <LI><A 
    href="#decl_LearnParameters">LearnParameters</A> 

    <LI><A 
    href="#decl_LearnStructure">LearnStructure</A> 

    <LI><A 
    href="#decl_LoadEvidBuf">LoadEvidBuf</A> 

    <LI><A 
    href="#decl_LoadNet">LoadNet</A> 

    <LI><A 
    href="#decl_MaskEvidBuf">MaskEvidBuf</A> 

    <LI><A 
    href="#decl_SaveEvidBuf">SaveEvidBuf</A> 

    <LI><A 
    href="#decl_SaveNet">SaveNet</A> 

    <LI><A 
    href="#decl_SetPGaussian">SetPGaussian</A> 

    <LI><A 
    href="#decl_SetProperty">SetProperty</A> 

    <LI><A 
    href="#decl_SetPTabular">SetPTabular</A> 

    </LI></UL>
  </UL>

<P></P>
<HR>

<H2><A name=decl_Class_BayesNet>Class BayesNet</A></H2>
<HR>

<P>Class BayesNet implements all functionality required for work with bayesian networks. 
The following functional groups can be distinguished:
<UL>
    <LI>Network creation (addition/deletion of nodes and arcs)<BR>
    <A href="#decl_AddNode">AddNode</A>,
    <A href="#decl_DelNode">DelNode</A>,
    <A href="#decl_AddArc">AddArc</A>,
    <A href="#decl_DelArc">DelArc</A>.
    </LI>
    <LI>Setting/getting parameters<BR>
    <A href="#decl_SetPTabular">SetPTabular</A>,
    <A href="#decl_GetPTabular">GetPTabular</A>,
    <A href="#decl_SetPGaussian">SetPGaussian</A>,
    <A href="#decl_GetGaussianMean">GetGaussianMean</A> ,
    <A href="#decl_GetGaussianCovar">GetGaussianCovar</A>,
    <A href="#decl_EditEvidence">EditEvidence</A>,
    <A href="#decl_ClearEvid">ClearEvid</A>,
    <A href="#decl_CurEvidToBuf">CurEvidToBuf</A>,
    <A href="#decl_AddEvidToBuf">AddEvidToBuf</A>,
    <A href="#decl_ClearEvidBuf">ClearEvidBuf</A>,
    <A href="#decl_GetChildren">GetChildren</A>,
    <A href="#decl_GetParents">GetParents</A>,
    <A href="#decl_GetNeighbours">GetNeighbours</A>,
    <A href="#decl_SetProperty">SetProperty</A>,
    <A href="#decl_GetProperty">GetProperty</A>
    </LI>
    <LI>Learning parameters<BR>
    <A href="#decl_LearnParameters">LearnParameters</A>
    </LI>
    <LI>Learning network structure<BR>
    <A href="#decl_LearnStructure">LearnStructure</A>
    </LI>
    <LI>Inference in network<BR>
    <A href="#decl_GetJPD">GetJPD</A>,
    <A href="#decl_GetMPE">GetMPE</A>
    </LI>
    <LI>Data sampling<BR>
    <A href="#decl_GenerateEvidences">GenerateEvidences</A>
    </LI>
    <LI>File I/O<BR>
    <A href="#decl_LoadNet">LoadNet</A>,
    <A href="#decl_SaveNet">SaveNet</A>,
    <A href="#decl_LoadEvidBuf">LoadEvidBuf</A>,
    <A href="#decl_SaveEvidBuf">SaveEvidBuf</A>
    </LI>
    <LI>more...</LI>
</UL>
</P>
<HR>


<H3><A name=decl_BayesNet>BayesNet</A></H3>
<P class=Blurb>Constructor</P>
<font class="interface">
BayesNet();
</font>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">BayesNet class has only default constructor.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Create empty bayes net:
</p>
<p class="example">
BayesNet net;
</p>
<HR>

<H3><A name=decl_AddNode>AddNode</A></H3>
<P class=Blurb>Adds nodes</P>
<font class="interface">
void AddNode(TokArr nodes, TokArr subnodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>List of nodes with nodes type (discrete or continuous) specifying. 
  <DT>subnodes
  <DD>Array of values that nodes can take (or names of dimensions for continuous nodes). 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several nodes with the same probable states into the network.</p>
<H5>
Example of usage
</H5>
<p class="description">
Add one discrete node "NodeA" with states "true" and "false" to bayes net:
</p>
<p class="example">
net.AddNode(discrete^"NodeA", "true false");
</p>
<p class="description">
Add one-dimensional continuous node "NodeA" to bayes net:
</p>
<p class="example">
net.AddNode(continuous^"NodeA", "dim1");
</p>
<p class="description">
Add discrete nodes "NodeA" and "NodeB" with states "true" and "false" to bayes net:
</p>
<p class="example">
net.AddNode(discrete^"NodeA NodeB", "true false");
</p>
<HR>

<H3><A name=decl_DelNode>DelNode</A></H3>
<P class=Blurb>Deletes nodes</P>
<font class="interface">
void DelNode(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of names of nodes to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several nodes from network together with all adjacent edges. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete nodes "NodeA" and "NodeB" from bayes net:
</p>
<p class="example">
net.DelNode("NodeA NodeB");
</P>
<HR>

<H3><A name=decl_GetNodeType>GetNodeType</A></H3>
<P class=Blurb>Returns types of the given nodes</P>
<font class="interface">
TokArr GetNodeType(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes whose type is interesting. 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns array of types (discrete or continuous) of given nodes.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get array of types of nodes "NodeA" and "NodeB":
</p>
<p class="example">
   TokArr nodeTypes = net.GetNodeType("NodeA NodeB");
</P>
<HR>

<H3><A name=decl_AddArc>AddArc</A></H3>
<P class=Blurb>Adds arc</P>
<font class="interface">
void AddArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs. 
  <DT>to
  <DD>Array of ending nodes of the arcs</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several arcs to the network. Each starting node is connected with each ending node.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Add edge from node "NodeA" to node "NodeB":
</p>
<p class="example">
net.AddArc("NodeA", "NodeB");
</P>
<p class="description">
Add two edges: from "NodeA" to "NodeB" and from "NodeA" to "NodeC":
</p>
<p class="example">
net.AddArc("NodeA", "NodeB NodeC");
</P>
<p class="description">
Add four edges: from "NodeA" to "NodeC", from "NodeA" to "NodeD", from "NodeB" to "NodeC" and from "NodeB" to "NodeD":
</p>
<p class="example">
net.AddArc("NodeA NodeB", "NodeC NodeD");
</P>
<HR>

<H3><A name=decl_DelArc>DelArc</A></H3>
<P class=Blurb>Deletes arcs</P>
<font class="interface">
void DelArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs to delete. 
  <DT>to
  <DD>Array of ending nodes of the arcs to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several arcs from the network. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete edge from node "NodeA" to node "NodeB":
</p>
<p class="example">
net.DelArc("NodeA", "NodeB");
</P>
<p class="description">
Delete following two edges if they exist: from "NodeA" to "NodeB" and from "NodeA" to "NodeC":
</p>
<p class="example">
net.DelArc("NodeA", "NodeB NodeC");
</P>
<p class="description">
Add all edges with starting node "NodeA" or "NodeB" and ending node "NodeC" or "NodeD":
</p>
<p class="example">
net.DelArc("NodeA NodeB", "NodeC NodeD");
</P>
<HR>

<H3><A 
name=decl_GetNeighbours>GetNeighbours</A></H3>
<P class=Blurb>Returns list of neighbours for given node. 
</P>
<font class="interface">
TokArr GetNeighbours(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose neighbours are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of neighbours for given node or some nodes. If neighbours of several nodes are demanded then neighbors of every node are in the result, each neighbor is once to be found in list.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get neighbors of node "NodeA":
</p>
<p class="example">
TokArr NodeANeighbors = net.GetNeighbours("NodeA");
</P>
<p class="description">
Get neighbors of node "NodeA" and neighbors of node "NodeB". If node "NodeC" is neighbor both "NodeA" and "NodeB" then it is once to be found in result list of neighbors:
</p>
<p class="example">
TokArr NodeAandBNeighbors = net.GetNeighbours("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_GetParents>GetParents</A></H3>
<P class=Blurb>Returns list of parents for given node. 
</P>
<font class="interface">
TokArr GetParents(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose parents are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of parents for given node or some nodes. If parents of several nodes are demanded then parents of every node are in the result, each parent is once to be found in result list.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get parents of node "NodeA":
</p>
<p class="example">
TokArr NodeAParents = net.GetParents("NodeA");
</P>
<p class="description">
Get parents of node "NodeA" and parents of node "NodeB". If node "NodeC" is parent both "NodeA" and "NodeB" then it is once to be found in result list of parents:
</p>
<p class="example">
TokArr NodeAandBParents = net.GetParents("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_GetChildren>GetChildren</A></H3>
<P class=Blurb>Returns list of children for given node. 
</P>
<font class="interface">
TokArr GetChildren(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose children are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of children for given node or some nodes.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get children of node "NodeA":
</p>
<p class="example">
TokArr NodeAChildren = net.GetChildren("NodeA");
</P>
<p class="description">
Get children of node "NodeA" and children of node "NodeB". If node "NodeC" is child both "NodeA" and "NodeB" then it is once to be found in result list of children:
</p>
<p class="example">
TokArr NodeAandBChildren = net.GetChildren("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_SetPTabular>SetPTabular</A></H3>
<P class=Blurb>Assigns probability to one or several values of one discrete node 
</P>
<font class="interface">
void SetPTabular(TokArr value, TokArr prob, TokArr parentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Array of node values for wich probabilities are set. 
  <DT>prob
  <DD>Array of values of probabilities.
  <DT>parentValue
  <DD>Array of values of discrete parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets [conditional] probability for one or several values of the discrete node 
[for given values of parents]. Sizes of values array and probabilities array must be the same. While distribution 
of probabilities is not specified it is considered uniform.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Lets node "NodeA" has not parents and can take on two values: "true" and "false". Its distribution of probabilities is unconditional. 
</p>
<p class="example">
net.SetPTabular("NodeA^true NodeA^false", "0.7 0.3");
</P>
<p class="description">
Lets node "NodeB" can take on values "true" and "false" too and has only one parent "NodeA". Distribution of 
probabilities of "NodeB" is conditional. It is necessary to call SetPTabular method for each configuration of 
parents values:  
</p>
<p class="example">
net.SetPTabular("NodeB^true NodeB^false", "0.99 0.01", "NodeA^true");<br>
net.SetPTabular("NodeB^true NodeB^false", "0.4 0.6", "NodeA^false");
</P>
<HR>

<H3><A 
name=decl_GetPTabular>GetPTabular</A></H3>
<P class=Blurb>Returns probability of discrete node. 
</P>
<font class="interface">
TokArr GetPTabular(TokArr node, TokArr parents = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node or array of node values whose probabiliteis are needed. 
  <DT>parents
  <DD>Values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns probability of discrete node. If values of parents are given then probabilites only 
for these parents configurations will be returned. If concrete values of node are diven in array node then
only probabilities of these values will be returned. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Lets consider getting probabilities for node "NodeB" from example for SetPTabular method. Some variants to get "NodeB"
probabilites are available:
</p>
<p class="example">
TokArr PNodeB = net.GetPTabular("NodeB");<br>
TokArr PNodeBTrue = net.GetPTabular("NodeB^true");<br>
TokArr PNodeBNodeATrue = net.GetPTabular("NodeB", "NodeA^true");<br>
TokArr PNodeBTrueNodeAFalse = net.GetPTabular("NodeB^true", "NodeA^false");
</P>
<p class="description">
Results of these calls:
</p>
<p class="example">
<table>
<tr>
  <td>PNodeB</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01 NodeB^true^NodeA^false^0.4 NodeB^false^NodeA^false^0.6"</td>
</tr>
<tr>
  <td>PNodeBTrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^true^NodeA^false^0.4"</td>
</tr>
<tr>
  <td>PNodeBNodeATrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01"</td>
</tr>
<tr>
  <td>PNodeBTrueNodeAFalse</td>
  <td>"NodeB^true^NodeA^false^0.4"</td>
</tr>
</table>
</P>
<HR>

<H3><A 
name=decl_SetPGaussian>SetPGaussian</A></H3>
<P class=Blurb>Sets parameters for one-dimensional gaussian variate. 
</P>
<font class="interface">
void SetPGaussian(TokArr var, TokArr mean = TokArr(), TokArr variance = TokArr(), TokArr weight = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>var
  <DD>Name of node whose probability is set. 
  <DT>mean
  <DD>Vector of means. 
  <DT>variance
  <DD>Matrix of variance - one number for one-dimensional variate.
  <DT>weight
  <DD>Matrix of weights - vector for one-dimensional variate.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function set parameters for one-dimensional gaussian variate. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's set gaussian distribution for the node without parents.
</p>
<p class="example">
net.SetPGaussian("x0", "1.0", "4.0");
</p>
<p class="description">
Let's set gaussian distribution for the node with two parents.
</p>
<p class="example">
net.SetPGaussian("x2", "0.0", "2.0", "1.0 2.0");
</P>
<HR>

<H3><A 
name=decl_EditEvidence>EditEvidence</A></H3>
<P class=Blurb>Edits current evidence 
</P>
<font class="interface">
void EditEvidence(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets or edits current evidence. New observed nodes are added to current evidence
with EditEvidence method or old vales of observed nodes are changed.
</p>
<H5>
Example of usage
</H5>
<p class="description">
</p>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.EditEvidence("NodeA^false NodeC^true");
</P>
<p class="description">
In current evidence there are three observed nodes now: "NodeA", "NodeB" (both are false) and "NodeC"(true).
</p>
<HR>

<H3><A 
name=decl_ClearEvid>ClearEvid</A></H3>
<P class=Blurb>Clears current evidence. 
</P>
<font class="interface">
void ClearEvid();
</font>
<H5>Discussion</H5>
<p class="description">The function clears current evidence. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.ClearEvid();
</P>
<p class="description">
Current evidence is empty now.
</p>
<HR>

<H3><A 
name=decl_CurEvidToBuf>CurEvidToBuf</A></H3>
<P class=Blurb>Stores current evidence to the evidence buffer. 
</P>
<font class="interface">
void CurEvidToBuf();
</font>
<H5>Discussion</H5>
<p class="description">The function stores current evidence to the buffer of evedences. Current evidence is not cleared.
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.EditEvidence("NodeA^false NodeC^true");<br>
net.CurEvidToBuf();<br>
net.EditEvidence("NodeB^true");<br>
net.CurEvidToBuf();
</P>
<p class="description">
In current evidence there are three observed nodes now: "NodeA" takes on value "false", "NodeB" and "NodeC" take on values "true".
</p>
<p class="description">
In evidence buffer there are two evidences now. In first evidence "NodeA" and "NodeB" take on values "false", and "NodeC" 
takes on value "true". In second one "NodeA" takes on value "false", "NodeB" and "NodeC" take on values "true".
</p>
<HR>

<H3><A 
name=decl_AddEvidToBuf>AddEvidToBuf</A></H3>
<P class=Blurb>Adds evidence to the evidence buffer. 
</P>
<font class="interface">
void AddEvidToBuf(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds evidence to the buffer. Current evidence is not changed.
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");
</P>
<p class="description">
In evidence buffer there are two evidences now. In first evidence "NodeA" takes on value "true" and "NodeB" takes on value "false".
In second one "NodeA" takes on value "false" and "NodeC" takes on value "true".
</p>
<HR>

<H3><A 
name=decl_ClearEvidBuf>ClearEvidBuf</A></H3>
<P class=Blurb>Clears evidence buffer. 
</P>
<font class="interface">
void ClearEvidBuf();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function clears evidence buffer. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.ClearEvidBuf();
</P>
<p class="description">
Evidence buffer is empty now.
</p>
<HR>

<H3><A 
name=decl_MaskEvidBuf>MaskEvidBuf</A></H3>
<P class=Blurb>Hides nodes of current learning buffer with given probability. 
</P>
<font class="interface">
void MaskEvidBuf(TokArr whatNodes = "");
</font>
<H5>Arguments</H5>
<DL>
  <DT>whatNodes
  <DD>Array of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function hides nodes of current learning buffer with given probability. The function applies for all existing 
values (hidden and observed), i.e. observed may become hidden and hidden may become observed. By default this function 
unhides all hidden values. If a node did not have sample then it can not be unhidden.
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>

<H3><A 
name=decl_LearnParameters>LearnParameters</A></H3>
<P class=Blurb>Learns network parameters. 
</P>
<font class="interface">
void LearnParameters(TokArr aValue[] = NULL, int nValue = 0);
</font>
<H5>Arguments</H5>
<DL>
  <DT>aValue
  <DD>Array of evidences. Each evidence is array of observed nodes with values. 
  <DT>nValue
  <DD>Number of evidences.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function learns network parameters using evidence buffer. If function with parameters is called then new 
evidences are added to evidence buffer then learning is started up. Learning algorithm is set to property "Learning" with 
method <A href="#decl_SetProperty">SetProperty()</A>. By default EM learning is used. Besides Bayes learning is availabile.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Folowing three code pieces are equal:
</p>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.LearnParameters();
</P>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
TokArr evidences[] = {"NodeA^false NodeC^true"};<br>
net.LearnParameters(evidences);
</P>
<p class="example">
TokArr evidences[] = {"NodeA^true NodeB^false", "NodeA^false NodeC^true"};<br>
net.LearnParameters(evidences);
</P>
<HR>

<H3><A 
name=decl_LearnStructure>LearnStructure</A></H3>
<P class=Blurb>Learns structure of the network. 
</P>
<font class="interface">
void LearnStructure(TokArr aValue[], int nValue);
</font>
<H5>Arguments</H5>
<DL>
  <DT>aValue
  <DD>Array of evidences. Each evidence is array of observed nodes with values. 
  <DT>nValue
  <DD>Number of evidences.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function learn structure of the network using evidence buffer. If function with parameters is called then new 
evidences are added to evidence buffer then learning is started up. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Folowing three code pieces are equal:
</p>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.LearnStructure();
</P>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
TokArr evidences[] = {"NodeA^false NodeC^true"};<br>
net.LearnStructure(evidences);
</P>
<p class="example">
TokArr evidences[] = {"NodeA^true NodeB^false", "NodeA^false NodeC^true"};<br>
net.LearnStructure(evidences);
</P>
<HR>

<H3><A 
name=decl_GetMPE>GetMPE</A></H3>
<P class=Blurb>Returns MPE. 
</P>
<font class="interface">
TokArr GetMPE(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns most probable explanation (MPE) for specified nodes using current evidence. The inference algorithm
is set to property "Inference" with method <A href="#decl_SetProperty">SetProperty()</A>. By default Pearl inference is used. Besides Gibbs sampling,
Junction Tree inference and Naive inference are availabile. Corresponding property "Inference" values are "pearl", "gibbs",
"jtree", "naive".
</font>
<H5>
Example of usage
</H5>
<p class="description">
Get MPE for node "NodeA" with Junction Tree inference:
</p>
<p class="example">
net.SetProperty("Inference", "jtree");<br>
TokArr jtreeMPENodeA = net.GetMPE("NodeA");
</P>
<p class="description">
Get MPE for nodes "NodeA" and "NodeB" with Pearl inference (nodes "NodeA" and "NodeB" must be from the same family):
</p>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
TokArr pearlMPENodeA = net.GetMPE("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_GetJPD>GetJPD</A></H3>
<P class=Blurb>Returns JPD. 
</P>
<font class="interface">
TokArr GetJPD(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns joint probability distribution (JPD) for specified nodes using current evidence. The inference algorithm
is set to property "Inference" with method <A href="#decl_SetProperty">SetProperty()</A>. By default Pearl inference is used. Besides Gibbs sampling,
Junction Tree inference and Naive inference are availabile. Corresponding property "Inference" values are "pearl", "gibbs",
"jtree", "naive".
</font>
<H5>
Example of usage
</H5>
<p class="description">
Get JPD for node "NodeA" with Junction Tree inference:
</p>
<p class="example">
net.SetProperty("Inference", "jtree");<br>
TokArr jtreeJPDNodeA = net.GetJPD("NodeA");
</P>
<p class="description">
Get JPD for nodes "NodeA" and "NodeB" with Pearl inference (nodes "NodeA" and "NodeB" must be from the same family):
</p>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
TokArr pearlJPDNodeA = net.GetJPD("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_SetProperty>SetProperty</A></H3>
<P class=Blurb>Sets value to the property.
</P>
<font class="interface">
void SetProperty(const char *name, const char *value);
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property. 
  <DT>value
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets value to the property with given name. The function is used to specify algorithms
for learning and getting MPE and JPD and to specify parameters of algorithms. User can use this function to define his own
properties. Used properties names with their possible values and descriptions are presented in table:
</p>
<table width="100%">
<tr><td width="50pt" Rowspan="10"></td>
<td><table BORDER="1">
  <tr>
     <td width="20%"><center><b>Property Name</b></center></td>
     <td width="25%"><center><b>Possible Values</b></center></td>
     <td width="55%"><center><b>Description</b></center></td>
  </tr>
  <tr>
     <td>"Learning"</td>
     <td>"bayes", "em"</td>
     <td>Algorithm for parameters learning. EM Learning is used by default.</td>
  </tr>
  <tr>
     <td>"EMMaxNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Maximum number of iterations of EM Learning algorithm. Default value is 5.</td>
  </tr>
  <tr>
     <td>"EMTolerance"</td>
     <td>Any positive float number</td>
     <td>Precision that  EM Learning algorithm runs up to. Default value is 0.001.</td>
  </tr>
  <tr>
     <td>"Inference"</td>
     <td>"pearl", "jtree", "gibbs", "naive"</td>
     <td>Inference algorithm that is used for getting MPE and JPD. Pearl Inference is used by default.</td>
  </tr>
  <tr>
     <td>"PearlMaxNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Maximum number of iterations of Pearl Inference algorithm. Default value is equal to number of nodes of net.</td>
  </tr>
  <tr>
     <td>"PearlTolerance"</td>
     <td>Any positive float number</td>
     <td>Precision that Pearl Inference algorithm runs up to. Default value is 1e-6.</td>
  </tr>
  <tr>
     <td>"GibbsNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Number of iterations of Gibbs Sampling Inference algorithm. Default value is 600.</td>
  </tr>
  <tr>
     <td>"GibbsThresholdIteration"</td>
     <td>Any positive integer number less than GibbsNumberOfIterations value</td>
     <td>Number of first itearation that use samples processing results of the previous iteration. Default value is 10.</td>
  </tr>
  <tr>
     <td>"GibbsNumberOfStreams"</td>
     <td>Any positive integer number</td>
     <td>Number of streams that generate independent samples. Default value is 1.</td>
  </tr>
</table><tr></td>
</table>
<H5>
Example of usage
</H5>
<p class="description">
Set Pearl inference for getting MPE and JPD:
</p>
<p class="example">
net.SetProperty("Inference", "pearl");
</P>
<p class="description">
Set maximum of iterations for Pearl inference:
</p>
<p class="example">
net.SetProperty("PearlMaxNumberOfIterations", "50");
</P>
<p class="description">
Set Bayes learning as algorithm for parameters learning:
</p>
<p class="example">
net.SetProperty("Learning", "em");
</P>
<p class="description">
Any other property can be defined by user:
</p>
<p class="example">
net.SetProperty("IterationsNumber", "100");
</P>
<HR>

<H3><A 
name=decl_GetProperty>GetProperty</A></H3>
<P class=Blurb>Returns value of the property with given name.
</P>
<font class="interface">
String GetProperty(const char *name) const;
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns value of the property with given name. If property was not set with 
<A href="#decl_SetProperty">SetProperty</A> method then empty string is returned.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
String inferenceType = net.GetProperty("Inference");<br>
String learningType = net.GetProperty("Learning");
</P>
<p class="description">
As result string inferenceType is "pearl" and string learningType is empty.
</p>
<HR>

<H3><A 
name=decl_GetGaussianMean>GetGaussianMean</A></H3>
<P class=Blurb>Returns mean of gaussian distribution. 
</P>
<font class="interface">
TokArr GetGaussianMean(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Name of node whose mean are needed</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns mean of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr MeanX2 = net.GetGaussianMean("x2");
</p>

<HR>

<H3><A 
name=decl_GetGaussianCovar>GetGaussianCovar</A></H3>
<P class=Blurb>Returns variance of gaussian distribution. 
</P>
<font class="interface">
TokArr GetGaussianCovar(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Name of node whose variance are needed. 
</DL>
<H5>Discussion</H5>
<p class="description">The function returns variance of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr CovarX2 = net.GetGaussianCovar("x2");
</P>
<HR>

<H3><A 
name=decl_SaveNet>SaveNet</A></H3>
<P class=Blurb>Saves network to file. 
</P>
<font class="interface">
void SaveNet(const char *filename);
</font>
<P>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function saves network to file of "xml" format with given name. Net structure and nodes distributions 
of probabilities are stored to file.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SaveNet("net.xml");
</P>
<HR>

<H3><A 
name=decl_SaveEvidBuf>SaveEvidBuf</A></H3>
<P class=Blurb>Saves evidence buffer content to file. 
</P>
<font class="interface">
int SaveEvidBuf(const char *filename, NetConst::ESavingType mode = NetConst::eCSV);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character depends on this parameter. Two separating characters are available: ',' (if mode is set to eCSV)
and tab (if mode is set to eTSV).</DD></DL>
<H5>Discussion</H5>
<p class="description">The function saves evidence buffer content to file of "cvs" format. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Save two evidences to file with ',' separator:
</p>
<p class="example">
net.ClearEvidBuf();<br>
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.SaveEvidBuf("evidence1.csv");
</P>
<p class="description">
Save the same two evidences to file with tab separator:
</p>
<p class="example">
net.ClearEvidBuf();<br>
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.SaveEvidBuf("evidence2.csv", NetConst::eTSV);
</P>
<HR>

<H3><A 
name=decl_LoadNet>LoadNet</A></H3>
<P class=Blurb>Loads network from file. 
</P>
<font class="interface">
void LoadNet(const char *filename);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads network from file with given name. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load net structure and distributions from file "net.xml":
</p>
<p class="example">
net.LoadNet("net.xml");
</P>
<HR>

<H3><A 
name=decl_LoadEvidBuf>LoadEvidBuf</A></H3>
<P class=Blurb>Loads evidence buffer content from file. 
</P>
<pre>
<font class="interface">
int LoadEvidBuf(const char *filename, 
                NetConst::ESavingType mode = NetConst::eCSV, 
                TokArr columns = TokArr());
</font>
</pre>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character used in file is explained by this parameter. Two separating characters are available: 
',' (if mode is set to eCSV) and tab (if mode is set to eTSV). 
  <DT>columns
  <DD>Names of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads evidence buffer content from file. Buffer is cleared before loading. We can load evidences created in
another net with another node names but with the same values of nodes. For this we must set new node names in evidences 
using array "columns". The function returns number of evidences loaded from file.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load evidences from file "evidence1.csv" with ',' separators and perform learning with them:
</p>
<p class="example">
net.LoadEvidBuf("evidence1.csv");<br>
net.LearnParameters();
</P>
<HR>
<!--
<H3><A 
name=decl_MakeUniformDistribution>MakeUniformDistribution</A></H3>
<P class=Blurb>Sets uniform distribution on all nodes. 
</P>
<font class="interface">
void MakeUniformDistribution();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function .... 
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>
-->
<H3><A 
name=decl_GenerateEvidences>GenerateEvidences</A></H3>
<P class=Blurb>Generate samples for the network. 
</P>
<font class="interface">
void GenerateEvidences( int nSamples, bool ignoreCurrEvid = false, TokArr whatNodes = "");
</font>
<H5>Arguments</H5>
<DL>
  <DT>nSamples
  <DD>Number of samples to generate. 
  <DT>ignoreCurrEvid 
  <DD>Flag of current evidence ignorance. If true - the current evidence will be ignored. Default value is false.  
  <DT>whatNodes 
  <DD>Array of names of variables to generate and portion of observed data. Default empty array means that all samples will be generated. </DD>
</DL>
<H5>Discussion</H5>
<p class="description">The function generates the specified number of samples from joint probability distribution of the network.
Samples may be generated using the current evidence (set by <A href="#decl_EditEvidence">EditEvidence</A> function)
 or ignoring the current evidence. The function allows generating samples with specified portion of missing variables.
If current evidence is taken into account (ignoreCurrEvid == true) then sampled values of nodes present in evidence
will be equal to values of current evidence. 
The sampled data can be generated so that there will be some portion of missing values - for every node user may specify the portion of 
non-missing values in the generated array.  
The newly generated samples will be added to internal buffer (learning buffer). To clear learning buffer use <A href="#decl_ClearEvidBuf">ClearEvidBuf</A>. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Generate 100 samples for all network nodes ignoring current evidence: 
</p>
<p class="example">
GenerateEvidences( 100, true);
</P>
<p class="description">
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence:
</p>
<p class="example">
TokArr whatNodesToSample = TokArr("NodeA") & "NodeB" & "NodeC";<br>
GenerateEvidences(100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence. "NodeA" should contain 90% of observed values, "NodeB" and "NodeC" should contain 100% of observed data:
</p>
<p class="example">
    TokArr whatNodesToSample = Tok("NodeA")^0.9 & "NodeB" & Tok("NodeC")^1.0;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples for nodes "NodeA","NodeB" and "NodeC" using current evidence. All nodes should contain 90% of observed values:
</p>
<p class="example">
    TokArr whatNodesToSample = (Tok("NodeA") "NodeB" & Tok("NodeC") ) ^ 0.9;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples for all nodes using current evidence. All nodes should contain 90% of observed values:
</p>
<p class="example">
    TokArr whatNodesToSample = 0.9;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>
<hr>
</DIV></BODY></HTML>
