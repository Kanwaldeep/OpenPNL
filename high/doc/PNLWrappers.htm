<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML><HEAD><TITLE>PNL Wrappers Reference</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251"><LINK 
href="style.css" type=text/css charset=ISO-8859-1 
rel=STYLESHEET>
<META content="MSHTML 6.00.2800.1400" name=GENERATOR></HEAD>
<BODY>
<H1>PNL high-level interface</H1>
<HR>

<P>
<UL>
  <LI><A 
  href="#decl_Class_BayesNet">Class BayesNet</A> 
  <UL>
    <LI><A 
    href="#decl_AddArc">AddArc</A> 

    <LI><A 
    href="#decl_AddEvidToBuf">AddEvidToBuf</A> 

    <LI><A 
    href="#decl_AddNode">AddNode</A> 

    <LI><A 
    href="#decl_BayesNet">BayesNet</A> 

    <LI><A 
    href="#decl_ClearEvid">ClearEvid</A> 

    <LI><A 
    href="#decl_ClearEvidBuf">ClearEvidBuf</A> 

    <LI><A 
    href="#decl_CurEvidToBuf">CurEvidToBuf</A> 

    <LI><A 
    href="#decl_DelArc">DelArc</A> 

    <LI><A 
    href="#decl_DelNode">DelNode</A> 

    <LI><A 
    href="#decl_EditEvidence">EditEvidence</A> 

    <LI><A 
    href="#decl_GenerateEvidences">GenerateEvidences</A> 

    <LI><A 
    href="#decl_GetChildren">GetChildren</A> 

    <LI><A 
    href="#decl_GetGaussianMean">GetGaussianMean</A> 

    <LI><A 
    href="#decl_GetGaussianCovar">GetGaussianCovar</A> 

    <LI><A 
    href="#decl_GetJPD">GetJPD</A> 

    <LI><A 
    href="#decl_GetMPE">GetMPE</A> 

    <LI><A 
    href="#decl_GetNeighbours">GetNeighbours</A> 

    <LI><A 
    href="#decl_GetNodeType">GetNodeType</A> 

    <LI><A 
    href="#decl_GetParents">GetParents</A> 

    <LI><A 
    href="#decl_GetProperty">GetProperty</A> 

    <LI><A 
    href="#decl_GetPTabular">GetPTabular</A> 

    <LI><A 
    href="#decl_LearnParameters">LearnParameters</A> 

    <LI><A 
    href="#decl_LearnStructure">LearnStructure</A> 

    <LI><A 
    href="#decl_LoadEvidBuf">LoadEvidBuf</A> 

    <LI><A 
    href="#decl_LoadNet">LoadNet</A> 

    <LI><A 
    href="#decl_MaskEvidBuf">MaskEvidBuf</A> 

    <LI><A 
    href="#decl_SaveEvidBuf">SaveEvidBuf</A> 

    <LI><A 
    href="#decl_SaveNet">SaveNet</A> 

    <LI><A 
    href="#decl_SetPGaussian">SetPGaussian</A> 

    <LI><A 
    href="#decl_SetProperty">SetProperty</A> 

    <LI><A 
    href="#decl_SetPTabular">SetPTabular</A> 

    </LI></UL>
  </UL>

<P></P>
<HR>

<H2><A name=decl_Class_BayesNet>Class BayesNet</A></H2>
<HR>

<P>Class BayesNet implements all functionality required for work with bayesian networks. 
The following functional groups can be distinguished:
<UL>
    <LI>Network creation (addition/deletion of nodes and arcs)<BR>
    <A href="#decl_AddNode">AddNode</A>,
    <A href="#decl_DelNode">DelNode</A>,
    <A href="#decl_AddArc">AddArc</A>,
    <A href="#decl_DelArc">DelArc</A>.
    </LI>
    <LI>Setting/getting parameters<BR>
    <A href="#decl_SetPTabular">SetPTabular</A>,
    <A href="#decl_GetPTabular">GetPTabular</A>,
    <A href="#decl_SetPGaussian">SetPGaussian</A>,
    <A href="#decl_GetGaussianMean">GetGaussianMean</A> ,
    <A href="#decl_GetGaussianCovar">GetGaussianCovar</A>,
    <A href="#decl_EditEvidence">EditEvidence</A>,
    <A href="#decl_ClearEvid">ClearEvid</A>,
    <A href="#decl_CurEvidToBuf">CurEvidToBuf</A>,
    <A href="#decl_AddEvidToBuf">AddEvidToBuf</A>,
    <A href="#decl_ClearEvidBuf">ClearEvidBuf</A>,
    <A href="#decl_GetChildren">GetChildren</A>,
    <A href="#decl_GetParents">GetParents</A>,
    <A href="#decl_GetNeighbours">GetNeighbours</A>,
    <A href="#decl_SetProperty">SetProperty</A>,
    <A href="#decl_GetProperty">GetProperty</A>
    </LI>
    <LI>Learning parameters<BR>
    <A href="#decl_LearnParameters">LearnParameters</A>
    </LI>
    <LI>Learning network structure<BR>
    <A href="#decl_LearnStructure">LearnStructure</A>
    </LI>
    <LI>Inference in network<BR>
    <A href="#decl_GetJPD">GetJPD</A>,
    <A href="#decl_GetMPE">GetMPE</A>
    </LI>
    <LI>Data sampling<BR>
    <A href="#decl_GenerateEvidences">GenerateEvidences</A>
    </LI>
    <LI>File I/O<BR>
    <A href="#decl_LoadNet">LoadNet</A>,
    <A href="#decl_SaveNet">SaveNet</A>,
    <A href="#decl_LoadEvidBuf">LoadEvidBuf</A>,
    <A href="#decl_SaveEvidBuf">SaveEvidBuf</A>
    </LI>
    <LI>more...</LI>
</UL>
</P>
<HR>


<H3><A name=decl_BayesNet>BayesNet</A></H3>
<P class=Blurb>Constructor</P><PRE>BayesNet();
</PRE>
<P>
<DL>
</DL>
<P></P>
<P>BayesNet class has only default constructor.</P>
<HR>

<H3><A name=decl_AddNode>AddNode</A></H3>
<P class=Blurb>Adds nodes</P><PRE>void AddNode(TokArr nodes, TokArr subnodes);</PRE>
<P>
<DL>
  <DT>nodes
  <DD>List of nodes with nodes type (categoric or continuous) specifying. 
  <DT>subnodes
  <DD>Array of values that nodes can take (or names of dimensions for continuous nodes).
</DD></DL>
<P></P>
<P>The function adds one or several nodes into the network.</P>
<HR>

<H3><A name=decl_DelNode>DelNode</A></H3>
<P class=Blurb>Deletes nodes</P><PRE>void DelNode(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>Array of names of nodes to delete. 
  </DD></DL>
<P></P>
<P>The function deletes one or several nodes from network together with all adjacent edges. </P>
<HR>

<H3><A name=decl_GetNodeType>GetNodeType</A></H3>
<P class=Blurb>Returns types of the given nodes</P><PRE>TokArr GetNodeType(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>Array of nodes whose type is interesting. 
</DD></DL>
<P></P>
<P>The function returns array of types (discrete or continuous) of given nodes.</P>
<HR>

<H3><A name=decl_AddArc>AddArc</A></H3>
<P class=Blurb>Adds arc</P><PRE>void AddArc(TokArr from, TokArr to);
</PRE>
<P>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs. 
  <DT>to
  <DD>Array of ending nodes of the arcs</DD></DL>
<P></P>
<P>The function adds one or several arcs to the network. Each starting node is connected with each ending node.</P>
<HR>

<H3><A name=decl_DelArc>DelArc</A></H3>
<P class=Blurb>Deletes arcs</P><PRE>void DelArc(TokArr from, TokArr to);
</PRE>
<P>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs to delete. 
  <DT>to
  <DD>Array of ending nodes of the arcs to delete. 
  </DD></DL>
<P></P>
<P>The function deletes one or several arcs from the network. 
</P>
<HR>

<H3><A 
name=decl_GetNeighbours>GetNeighbours</A></H3>
<P class=Blurb>Returns list of neighbours for given node. 
</P><PRE>TokArr GetNeighbours(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>One or several nodes whose neighbours are need.</DD></DL>
<P></P>
<P>The function returns list of neighbours for given node or some nodes.
</P>
<HR>

<H3><A 
name=decl_GetParents>GetParents</A></H3>
<P class=Blurb>Returns list of parents for given node. 
</P><PRE>TokArr GetParents(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>One or several nodes whose parents are need.</DD></DL>
<P></P>
<P>The function returns list of parents for given node or some nodes. 
</P>
<HR>

<H3><A 
name=decl_GetChildren>GetChildren</A></H3>
<P class=Blurb>Returns list of children for given node. 
</P><PRE>TokArr GetChildren(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>One or several nodes whose children are need.</DD></DL>
<P></P>
<P>The function returns list of children for given node or some nodes.
</P>
<HR>

<H3><A 
name=decl_SetPTabular>SetPTabular</A></H3>
<P class=Blurb>Assigns probability to one or several values of one discrete node 
</P><PRE>void SetPTabular(TokArr value, TokArr prob, TokArr parentValue = TokArr());
</PRE>
<P>
<DL>
  <DT>value
  <DD>Array of node values for wich probabilities are set. 
  <DT>prob
  <DD>Array of values of probabilities.
  <DT>parentValue
  <DD>Array of values of discrete parents of the node.</DD></DL>
<P></P>
<P>The function sets [conditional] probability for one or several values of the discrete node 
[for given values of parents]. Sizes of value array and probability array must be the same.
</P>
<HR>

<H3><A 
name=decl_GetPTabular>GetPTabular</A></H3>
<P class=Blurb>Returns probability of discrete node. 
</P><PRE>TokArr GetPTabular(TokArr node, TokArr parents = TokArr());
</PRE>
<P>
<DL>
  <DT>node
  <DD>Name of node or array of node values whose probabiliteis are needed. 
  <DT>parents
  <DD>Values of parents of the node.</DD></DL>
<P></P>
<P>The function returns probability of discrete node. If values of parents are given then probabilites only 
for these parents configurations will be returned. If concrete values of node are diven in array node then
only probabilities of these values will be returned. 
</P>
<HR>

<H3><A 
name=decl_SetPGaussian>SetPGaussian</A></H3>
<P class=Blurb>Sets parameters for one-dimensional gaussian variate. 
</P><PRE>void SetPGaussian(TokArr var, TokArr mean = TokArr(), TokArr variance = TokArr(), TokArr weight = TokArr());
</PRE>
<P>
<DL>
  <DT>var
  <DD>Name of node whose probability is set. 
  <DT>mean
  <DD>Vector of means. 
  <DT>variance
  <DD>Matrix of variance - one number for one-dimensional variate.
  <DT>weight
  <DD>Matrix of weights - vector for one-dimensional variate.</DD></DL>
<P></P>
<P>The function set parameters for one-dimensional gaussian variate. 
</P>
<HR>

<H3><A 
name=decl_EditEvidence>EditEvidence</A></H3>
<P class=Blurb>Edits current evidence 
</P><PRE>void EditEvidence(TokArr values);
</PRE>
<P>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<P></P>
<P>The function sets or edit current evidence. 
</P>
<HR>

<H3><A 
name=decl_ClearEvid>ClearEvid</A></H3>
<P class=Blurb>Clears current evidence. 
</P><PRE>void ClearEvid();
</PRE>
<P>
<DL>
</DL>
<P></P>
<P>The function clears current evidence. 
</P>
<HR>

<H3><A 
name=decl_CurEvidToBuf>CurEvidToBuf</A></H3>
<P class=Blurb>Stores current evidence to the evidence buffer. 
</P><PRE>void CurEvidToBuf();
</PRE>
<P>
<DL>
</DL>
<P></P>
<P>The function stores current evidence to the buffer of evedences. 
</P>
<HR>

<H3><A 
name=decl_AddEvidToBuf>AddEvidToBuf</A></H3>
<P class=Blurb>Adds evidence to the evidence buffer. 
</P><PRE>void AddEvidToBuf(TokArr values);
</PRE>
<P>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<P></P>
<P>The function adds evidence to the buffer. Current evidence is not changed.
</P>
<HR>

<H3><A 
name=decl_ClearEvidBuf>ClearEvidBuf</A></H3>
<P class=Blurb>Clears evidence buffer. 
</P><PRE>void ClearEvidBuf();
</PRE>
<P>
<DL>
</DL>
<P></P>
<P>The function clears evidence buffer. 
</P>
<HR>

<H3><A 
name=decl_MaskEvidBuf>MaskEvidBuf</A></H3>
<P class=Blurb>Hides nodes of current learning buffer with given probability. 
</P><PRE>void MaskEvidBuf(TokArr whatNodes = "");
</PRE>
<P>
<DL>
  <DT>whatNodes
  <DD>Array of nodes.</DD></DL>
<P></P>
<P>The function hides nodes of current learning buffer with given probability. The function applies for all existing 
values (hidden and observed), i.e. observed may become hidden and hidden may become observed. By default this function 
unhides all hidden values. If a node did not have sample then it can not be unhidden.
</P>
<HR>

<H3><A 
name=decl_LearnParameters>LearnParameters</A></H3>
<P class=Blurb>Learns network parameters. 
</P><PRE>void LearnParameters(TokArr aValue[] = NULL, int nValue = 0);
</PRE>
<P>
<DL>
  <DT>aValue
  <DD>Array of evidences. Each evidence is array of observed nodes with values. 
  <DT>nValue
  <DD>Number of evidences.</DD></DL>
<P></P>
<P>The function learns network parameters using evidence buffer. If function with parameters is called then new 
evidences are added to evidence buffer then learning is started up. Learn algorithm is set to property "Learning" with 
method <A href="#decl_SetProperty">SetProperty()</A>. By default EM learning is used. Besides Bayes learning is availabile.
</P>
<HR>

<H3><A 
name=decl_LearnStructure>LearnStructure</A></H3>
<P class=Blurb>Learn structure of the network. 
</P><PRE>void LearnStructure(TokArr aValue[], int nValue);
</PRE>
<P>
<DL>
  <DT>aValue
  <DD>Array of evidences. Each evidence is array of observed nodes with values. 
  <DT>nValue
  <DD>Number of evidences.</DD></DL>
<P></P>
<P>The function learn structure of the network using evidence buffer. If function with parameters is called then new 
evidences are added to evidence buffer then learning is started up. Learn algorithm is set to property "Learning" with 
method <A href="#decl_SetProperty">SetProperty()</A>. By default EM learning is used. Besides Bayes learning is availabile.
</P>
<HR>

<H3><A 
name=decl_GetMPE>GetMPE</A></H3>
<P class=Blurb>Returns MPE. 
</P><PRE>TokArr GetMPE(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<P></P>
<P>The function returns most probable explanation (MPE) for specified nodes using current evidence. The inference algorithm
is set to property "Inference" with method <A href="#decl_SetProperty">SetProperty()</A>. By default Pearl inference is used. Besides Gibbs sampling,
Junction Tree inference and Naive inference are availabile.
</P>
<HR>

<H3><A 
name=decl_GetJPD>GetJPD</A></H3>
<P class=Blurb>Returns JPD. 
</P><PRE>TokArr GetJPD(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<P></P>
<P>The function returns joint probability distribution (JPD) for specified nodes using current evidence. The inference algorithm
is set to property "Inference" with method <A href="#decl_SetProperty">SetProperty()</A>. By default Pearl inference is used. Besides Gibbs sampling,
Junction Tree inference and Naive inference are availabile.
</P>
<HR>

<H3><A 
name=decl_SetProperty>SetProperty</A></H3>
<P class=Blurb>Sets value to the property.
</P><PRE>void SetProperty(const char *name, const char *value);
</PRE>
<P>
<DL>
  <DT>name
  <DD>Name of property. 
  <DT>value
  <DD>Array of nodes from one family.</DD></DL>
<P></P>
<P>The function sets value to the property with given name. 
</P>
<HR>

<H3><A 
name=decl_GetProperty>GetProperty</A></H3>
<P class=Blurb>Returns value of the property with given name.
</P><PRE>String GetProperty(const char *name) const;
</PRE>
<P>
<DL>
  <DT>name
  <DD>Name of property.</DD></DL>
<P></P>
<P>The function returns value of the property with given name.
</P>
<HR>

<H3><A 
name=decl_GetGaussianMean>GetGaussianMean</A></H3>
<P class=Blurb>Returns mean of gaussian distribution. 
</P><PRE>TokArr GetGaussianMean(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>Name of node whose mean are needed</DD></DL>
<P></P>
<P>The function returns mean of gaussian distribution. 
</P>
<HR>

<H3><A 
name=decl_GetGaussianCovar>GetGaussianCovar</A></H3>
<P class=Blurb>Returns variance of gaussian distribution. 
</P><PRE>TokArr GetGaussianCovar(TokArr nodes);
</PRE>
<P>
<DL>
  <DT>nodes
  <DD>Name of node whose variance are needed. 
</DL>
<P></P>
<P>The function returns variance of gaussian distribution. 
</P>
<HR>

<H3><A 
name=decl_SaveNet>SaveNet</A></H3>
<P class=Blurb>Saves network to file. 
</P><PRE>void SaveNet(const char *filename);
</PRE>
<P>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<P></P>
<P>The function saves network to file with given name. 
</P>
<HR>

<H3><A 
name=decl_SaveEvidBuf>SaveEvidBuf</A></H3>
<P class=Blurb>Saves evidence buffer content to file. 
</P><PRE>int SaveEvidBuf(const char *filename, NetConst::ESavingType mode = NetConst::eCSV);
</PRE>
<P>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character depends on this parameter. Two separating characters are available: ',' (if mode is set to eCSV)
and tab (if mode is set to eTSV).</DD></DL>
<P></P>
<P>The function saves evidence buffer content to file. 
</P>
<HR>

<H3><A 
name=decl_LoadNet>LoadNet</A></H3>
<P class=Blurb>Loads network from file. 
</P><PRE>void LoadNet(const char *filename);
</PRE>
<P>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<P></P>
<P>The function loads network from file with given name. 
</P>
<HR>

<H3><A 
name=decl_LoadEvidBuf>LoadEvidBuf</A></H3>
<P class=Blurb>Loads evidence buffer content from file. 
</P><PRE>int LoadEvidBuf(const char *filename, NetConst::ESavingType mode = NetConst::eCSV, TokArr columns = TokArr());
</PRE>
<P>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character used in file is explained by this parameter. Two separating characters are available: 
',' (if mode is set to eCSV) and tab (if mode is set to eTSV). 
  <DT>columns
  <DD>Names of nodes.</DD></DL>
<P></P>
<P>The function loads evidence buffer content from file. Buffer is cleared before loading. We can load evidences created in
another net with another node names but with the same values of nodes. For this we must set new node names in evidences 
using array "columns".
</P>
<HR>
<!--
<H3><A 
name=decl_MakeUniformDistribution>MakeUniformDistribution</A></H3>
<P class=Blurb>Sets uniform distribution on all nodes. 
</P><PRE>void MakeUniformDistribution();
</PRE>
<P>
<DL>
  </DL>
<P></P>
<P>The function .... 
</P>
<HR>
-->
<H3><A 
name=decl_GenerateEvidences>GenerateEvidences</A></H3>
<P class=Blurb>Generate samples for the network. 
</P><PRE>void GenerateEvidences( int nSamples, bool ignoreCurrEvid = false, TokArr whatNodes = "");
</PRE>
<P>
<DL>
  <DT>nSamples
  <DD>Number of samples to generate. 
  <DT>ignoreCurrEvid 
  <DD>Flag of current evidence ignorance. If true - the current evidence will be ignored. Default value is false.  
  <DT>whatNodes 
  <DD>Array of names of variables to generate and portion of observed data. Default empty array means that all samples will be generated. </DD>
</DL>
<P></P>
<P>The function generates the specified number of samples from joint probability distribution of the network.
Samples may be generated using the current evidence (set by <A href="#decl_EditEvidence">EditEvidence</A> function)
 or ignoring the current evidence. The function allows generating samples with specified portion of missing variables.
If current evidence is taken into account (ignoreCurrEvid == true) then sampled values of nodes present in evidence
will be equal to values of current evidence. 
The sampled data can be generated so that there will be some portion of missing values - for every node user may specify the portion of 
non-missing values in the generated array.  
The newly generated samples will be added to internal buffer (learning buffer). To clear learning buffer use <A href="#decl_ClearEvidBuf">ClearEvidBuf</A>. 
</P>


<h4>Example of usage.</h4>
Generate 100 samples for all network nodes ignoring current evidence: 
<pre>
    GenerateEvidences( 100, true);
</pre>
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence:
<pre>
    TokArr whatNodesToSample = TokArr("NodeA") & "NodeB" & "NodeC";
    GenerateEvidences( 100, false, whatNodesToSample);
</pre>
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence. "NodeA" should contain 90% of observed values, "NodeB" and "NodeC" should contain 100% of observed data:
<pre>
    TokArr whatNodesToSample = Tok("NodeA")^0.9 & "NodeB" & Tok("NodeC")^1.0;
    GenerateEvidences( 100, false, whatNodesToSample);
</pre>

Generate 100 samples for nodes "NodeA","NodeB" and "NodeC" using current evidence. All nodes should contain 90% of observed values:
<pre>
    TokArr whatNodesToSample = (Tok("NodeA") "NodeB" & Tok("NodeC") ) ^ 0.9;
    GenerateEvidences( 100, false, whatNodesToSample);
</pre>

Generate 100 samples for all nodes using current evidence. All nodes should contain 90% of observed values:
<pre>
    TokArr whatNodesToSample = 0.9;
    GenerateEvidences( 100, false, whatNodesToSample);
</pre>
<HR>


<H2><A name=Class_...</A>Class_...</H2>
<HR>

</DIV></BODY></HTML>
